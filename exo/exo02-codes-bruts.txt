



def count_base_dna(dna, base):
    """
    Counts the number of occurence of `base` (str) in `dna` (str)
    """
    i = 0  # counter
    for char in dna:
        if char == base:
            i += 1
    return i


dna = "ATGCGGACCTAT"
base = "C"
n = count_base_dna(dna, base)
# or (new) format string syntax
print("{base} appears {n} times in {dna}".format(base=base, n=n, dna=dna))







**********************************************************
**********************************************************

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Voici un exemple de code qui prend la valeur du signal Is mesuré pour une gamme étalon
dont les concentrations initiales Cs sont connues. Ensuite, on calcule l'absorbance définie comme :
$$A = - \log\left(\dfrac{I}{I_0}\right) $$ où I0 est l'absorbance du blanc.

Ayant deux points, on extrait ensuite la droite affine passant par ces deux points
pour avoir la réponse du détecteur.
"""

import numpy as np


def calc_absorbance(I, I0):
    """
    Calcul de l'absorbance
    - I est l'intensité lumineuse en sortie de l'échantillon (float)
    - I0 est l'intensité lumineuse pour le blanc (float)
    retourne l'absorbance (float)
    """
    return -np.log(I / I0)


def calc_droite(Abs, Cs):
    """
    Calcul de la pente et l'ordonnée à l'origine à partir de deux points
    - Abs : liste des absorbances de longueur 2
    - Cs : liste des concentrations de longueur 2
    retourne la pente et l'ordonnée à l'origine (tuple)
    """
    a = (Abs[1] - Abs[0]) / (Cs[1] - Cs[0])
    b = Abs[1] - a * Cs[1]
    return a, b  # slope, intercept


if __name__ == "__main__":
    # Intensité lumineuse pour le blanc
    I0 = 986
    # Intensités brutes en sortie du détecteur
    Is = [611, 281]
    # Liste qui contiendra les absorbances
    Abs = []
    # Valeurs des concentrations exprimée en mmol/L
    Cs = [2, 4]

    # Calcul de l'absorbance
    for I in Is:
        Abs.append(calc_absorbance(I, I0))

    # Calcul des paramètres de la droite affine
    droite = calc_droite(Abs, Cs)

    print("pente : {}, ordonnée à l'origine : {}".format(*droite))



**********************************************************
**********************************************************


#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Création de signaux périodiques

On crée un signal périodique, celui-ci sera ajouté à la suite des listes
`ts` et `ys` si jamais ces deux listes sont non vides, sinon on doit retourner une période.

Le but est ici d'avoir à la suite un signal sinusoïdal suivi d'un signal triangulaire suivi d'un signal carré.
Le signal final doit être continu (excepté aux discontinuités du signal carré).
"""

#### Bad mauvais import de l'alias, du coup les fonctions dans le namespace numpy ne fonctionnent pas
#### en général lié à un mauvais copier coller depuis internet
# $$# import numpy
#### Good
import numpy as np  # ££$


# import de librairie pour avoir un aperçu du résultat,
# PAS de bug dans les deux lignes ci-dessous
import matplotlib as mpl
import matplotlib.pyplot as plt

# $$# def make_sinusoid(amplitude, period=1, steps=100):
def make_sinusoid(amplitude, period=1, steps=100, ts=None, ys=None):  # ££$
    """
    crée un signal sinusoïdal, retourne deux listes :
    - une liste avec les abscisses temporelles,
    - l'autre avec le signal
    ces deux listes sont ajoutées aux listes `ts` et `ys`,
    avec un décalage de l'abscisse temporelle pour le temps si nécessaire

    Paramètres :
    - amplitude (float) : amplitude du signal
    - period (float) : période du signal
    - steps (int) : nombre de pas pour l'échantillonage de la fonction
    - ts (list) :  liste à laquelle on va ajouter le signal
    """

    #### GOOD : initialisation d'objet mutables au sein de la fonction pour des arguments optionnels
    if ts is None:  # ££$
        ts = []  # ££$
    if ys is None:  # ££$
        ys = []  # ££$

    #### Bad en trop => conflit de nom de variable dans deux namespaces différents
    #### en déclarant ts ici, on créé une variable interne à la fonction, ce qui fait
    #### que le extend va porter sur la variable interne à la fonction et pas la variable globale
    # $$# ts = list(np.linspace(0,period,steps))

    # création de l'ensemble des abscisses temporelles
    # la fonction linspace va créer steps points régulièrement espacés entre 0 et period
    tss = np.linspace(0, period, steps)

    # Calcul de l'amplitude pour chacun des pas de temps
    #### Good
    amplitudes = amplitude * np.sin(tss * 2 * np.pi / period)  # ££$
    #### Bad : oubli de la pulsation
    # $$# amplitudes = amplitude * np.sin(tss)

    #### Good : fait le shift
    if len(ts) > 0:  # ££$
        tss += max(ts)  # ££$

    ts.extend(list(tss))
    ys.extend(list(amplitudes))

    #### Bad : pas de valeur retour de la fonction
    return tss, amplitudes  # ££$


# $$# def make_triangle(amplitude, period=1, steps=100):
def make_triangle(amplitude, period=1, steps=100, ts=None, ys=None):  # ££$
    """
    crée un signal triangulaire, retourne deux listes :
    - une liste avec les abscisses temporelles,
    - l'autre avec le signal
    ces deux listes sont ajoutées aux listes `ts` et `ys`,
    avec un décalage de l'abscisse temporelle pour le temps si nécessaire

    Paramètres :
    - amplitude (float) : amplitude du signal
    - period (float) : période du signal
    - steps (int) : nombre de pas pour l'échantillonage de la fonction
    - ts (list) :  liste à laquelle on va ajouter le signal
    """

    if ts is None:  # ££$
        ts = []  # ££$
    if ys is None:  # ££$
        ys = []  # ££$

    # calcul de la pente associée au signal qui sera l'incrément entre deux pas de temps
    slope = 4 * amplitude / steps

    # création de l'ensemble des abscisses temporelles
    # la fonction linspace va créer steps points régulièrement espacés entre 0 et period
    tss = np.linspace(0, period, steps)
    # amplitude du signal correspondant à chaque abscisse
    amplitudes = []

    # indice correspondant au pas de temps
    current_step = 1  # ££$
    # $$# current_step = 0
    amplitudes.append(0)  # ££$
    current_amplitude = 0
    """
    on fait un signal triangulaire découpé en 4 morceaux :
    - lors du premier quart de période on incrémente d'une valeur égale à la pente
    - sur les deux quarts de période suivants on soustrait d'une valeur égale à la pente
    - lors du dernier quart de période on incrémente d'une valeur égale à la pente
    """
    while current_step < steps:
        if current_step < steps // 4:
            current_amplitude += slope
            amplitudes.append(current_amplitude)
        elif current_step < 3 * steps // 4:
            current_amplitude -= slope
            amplitudes.append(current_amplitude)
        else:
            current_amplitude += slope
            amplitudes.append(current_amplitude)
        #### BAD :  non bouclage d'un while => boucle infinie
        current_step += 1  # ££$
    # $$# current_step += 1
    if len(ts) > 0:  # ££$
        tss += max(ts)  # ££$

    ts.extend(tss)
    ys.extend(list(amplitudes))

    #### Bad : pas de valeur retour de la fonction
    return tss, amplitudes  # ££$


# $$# def make_square(amplitude, period=1, steps=100):
def make_square(amplitude, period=1, steps=100, ts=None, ys=None):  # ££$
    """
    crée un signal rectangulaire, retourne deux listes :
    - une liste avec les abscisses temporelles,
    - l'autre avec le signal
    ces deux listes sont ajoutées aux listes `ts` et `ys`,
    avec un décalage de l'abscisse temporelle pour le temps si nécessaire

    Paramètres :
    - amplitude (float) : amplitude du signal
    - period (float) : période du signal
    - steps (int) : nombre de pas pour l'échantillonage de la fonction
    - ts (list) :  liste à laquelle on va ajouter le signal
    """
    #### GOOD : initialisation d'objet mutables au sein de la fonction pour des arguments optionnels
    if ts is None:  # ££$
        ts = []  # ££$
    if ys is None:  # ££$
        ys = []  # ££$
    # création de l'ensemble des abscisses temporelles
    tss = np.linspace(0, period, steps)
    amplitudes = []
    for step in range(steps):
        if step < steps // 2:
            amplitudes.append(amplitude)
        else:
            amplitudes.append(-amplitude)
    if len(ts) > 0:  # ££$
        tss += max(ts)  # ££$

    ts.extend(list(tss))
    ys.extend(list(amplitudes))

    return tss, amplitudes  # ££$


if __name__ == "__main__":
    ts = []
    ys = []
    pas = 100

    tss, amplitudes = make_sinusoid(4, 8, pas, ts=ts, ys=ys)  # ££$
    # $$# make_sinusoid(4, 8,pas)
    tss, amplitudes = make_triangle(4, 8, pas, ts=ts, ys=ys)  # ££$
    # $$# make_triangle(4, 8,pas)
    tss, amplitudes = make_square(4, 8, pas, ts=ts, ys=ys)  # ££$
    # $$# make_square(4, 8,pas)

    # Affichage du signal final, pas de bug dans les deux lignes ci-dessous
    plt.plot(ts, ys)
    plt.show()
